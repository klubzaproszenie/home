// Replace the mouse tracking section in initMainPage() with this updated code:

// Zmienne do śledzenia ruchu kursora
let mouseX = 0;
let mouseY = 0;

const audio = new Audio('muza.mp3');
audio.loop = true;

// Create AudioContext and nodes for smooth audio control
let audioContext;
let source;
let gainNode;
let analyser;
let delayNode;
let feedbackGain;
let wetGain;
let dryGain;

// Smoothing variables
let targetPlaybackRate = 1.0;
let currentPlaybackRate = 1.0;
let targetDelayTime = 0;
let currentDelayTime = 0;
const smoothingFactor = 0.05; // How quickly to interpolate

// Audio control display elements
const audioControlInfo = document.getElementById('audioControlInfo');
const speedDisplay = document.getElementById('speedDisplay');
const delayDisplay = document.getElementById('delayDisplay');

try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create nodes
    source = audioContext.createMediaElementSource(audio);
    gainNode = audioContext.createGain();
    analyser = audioContext.createAnalyser();
    
    // Create delay effect chain
    delayNode = audioContext.createDelay(3.0); // Max 3 seconds delay
    feedbackGain = audioContext.createGain();
    wetGain = audioContext.createGain();
    dryGain = audioContext.createGain();
    
    // Set initial values
    delayNode.delayTime.value = 0;
    feedbackGain.gain.value = 0.4; // Feedback amount (0-1)
    wetGain.gain.value = 0.3; // Wet signal level
    dryGain.gain.value = 1.0; // Dry signal level
    
    // Connect nodes for delay effect
    // Dry path: source -> dryGain -> gainNode
    source.connect(dryGain);
    dryGain.connect(gainNode);
    
    // Wet path: source -> delayNode -> feedbackGain -> delayNode (feedback loop)
    //                                -> wetGain -> gainNode
    source.connect(delayNode);
    delayNode.connect(feedbackGain);
    feedbackGain.connect(delayNode); // Feedback loop
    delayNode.connect(wetGain);
    wetGain.connect(gainNode);
    
    // Final output chain
    gainNode.connect(analyser);
    analyser.connect(audioContext.destination);
    
    // Set initial gain
    gainNode.gain.value = 1.0;
} catch (e) {
    console.log('Web Audio API not supported:', e);
}

// Smooth audio update loop
function updateAudioSmooth() {
    if (isFlipped && !audio.paused) {
        // Smooth interpolation for playback rate
        currentPlaybackRate += (targetPlaybackRate - currentPlaybackRate) * smoothingFactor;
        
        // Apply the smoothed playback rate
        if (Math.abs(currentPlaybackRate - audio.playbackRate) > 0.01) {
            audio.playbackRate = currentPlaybackRate;
        }
        
        // Smooth interpolation for delay time
        if (delayNode) {
            currentDelayTime += (targetDelayTime - currentDelayTime) * smoothingFactor;
            
            // Apply the smoothed delay time
            if (Math.abs(currentDelayTime - delayNode.delayTime.value) > 0.001) {
                delayNode.delayTime.setValueAtTime(currentDelayTime, audioContext.currentTime);
            }
        }
        
        // Update display
        speedDisplay.textContent = currentPlaybackRate.toFixed(2) + 'x';
        delayDisplay.textContent = Math.round(currentDelayTime * 1000) + 'ms';
    }
    
    requestAnimationFrame(updateAudioSmooth);
}
updateAudioSmooth();

// Śledzenie ruchu myszy - updated for position-based control
document.addEventListener('mousemove', (e) => {
    mouseX = e.clientX;
    mouseY = e.clientY;
    
    if (isFlipped && permissionGranted && !audio.paused) {
        // Y-axis controls playback speed (0.5x to 2.0x)
        // Top of screen = 2.0x, Bottom = 0.5x
        const yRatio = mouseY / window.innerHeight;
        targetPlaybackRate = 2.0 - (yRatio * 1.5); // 2.0 at top, 0.5 at bottom
        targetPlaybackRate = Math.max(0.5, Math.min(2.0, targetPlaybackRate));
        
        // X-axis controls delay time (0ms to 3000ms)
        // Left side = 0ms, Right side = 3000ms
        const xRatio = mouseX / window.innerWidth;
        targetDelayTime = xRatio * 3.0; // 0 to 3 seconds
        targetDelayTime = Math.max(0, Math.min(3.0, targetDelayTime));
        
        // Show control info when audio is playing
        audioControlInfo.classList.add('show');
    }
});

// Update the flipPage function to show audio controls:
function flipPage() {
    isFlipped = true;
    currentRotation = -180;
    page1.classList.add('flipped');
    page1.style.transform = 'rotateY(-180deg)';
    page1.style.zIndex = '1';
    
    hideSwipeHint();
    clearTimeout(hintTimeout);
    
    // Reset audio parameters for smooth start
    targetPlaybackRate = 1.0;
    currentPlaybackRate = 1.0;
    targetDelayTime = 0;
    currentDelayTime = 0;
    audio.preservesPitch = false;
    audio.currentTime = 0;
    
    // Enhanced audio playing with multiple fallbacks
    const playAudio = () => {
        // Resume AudioContext if needed
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        const playPromise = audio.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                console.log('Audio playing successfully');
                permissionGranted = true;
                
                // Fade in the audio smoothly
                if (gainNode) {
                    gainNode.gain.setValueAtTime(0.01, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(1.0, audioContext.currentTime + 0.5);
                }
                
                // Show audio control info
                audioControlInfo.classList.add('show');
            }).catch(err => {
                console.log('Audio play failed:', err);
                
                // If failed, try to unlock on next interaction
                if (!permissionGranted) {
                    const retryPlay = () => {
                        audio.play().catch(e => console.log('Retry failed:', e));
                        document.removeEventListener('click', retryPlay);
                        document.removeEventListener('touchend', retryPlay);
                    };
                    document.addEventListener('click', retryPlay, { once: true });
                    document.addEventListener('touchend', retryPlay, { once: true });
                }
            });
        }
    };
    
    // Try to play immediately
    playAudio();
    
    // Also try after a small delay (helps on some mobile browsers)
    setTimeout(playAudio, 100);
    
    startMusicParticles();
}

// Update the unflipPage function to hide audio controls:
function unflipPage() {
    isFlipped = false;
    currentRotation = 0;
    page1.classList.remove('flipped');
    page1.style.transform = 'rotateY(0deg)';
    page1.style.zIndex = '3';
    
    resetHintTimer();
    
    // Hide audio control info
    audioControlInfo.classList.remove('show');
    
    audio.pause();
    audio.playbackRate = 1.0;
    if (delayNode) {
        delayNode.delayTime.value = 0;
    }
    stopMusicParticles();
}
